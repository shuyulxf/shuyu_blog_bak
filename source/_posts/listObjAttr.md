title: 对象相关
tags: [learning,js]
type: tags
date: 2016-02-27 14:09:52
---
列举对象的属性：
如果用for-in来列举对象中的属性，则可以列出所有属性，属性类型包括方法和一般的属性值。
若要过滤掉类型为方法的属性使用：typeof obj[name] != "function"这其中包括对象定义的属性和从原型链中继承来的属性。要过滤继承来的属性，则可以使用obj.hasOwnProperty(name)。若该值为true，则表示该属性是该对象定义的，若为false为从原型链中继承的。
<!-- more -->
原型链：
原型链在检索属性的时候才用。如果在该对象中没有找到属性，就会沿原型链向上查找，如果找到则返回该结果，如果没有找到则返回undefined。如果修改非该对象自定义的属性，而是原型中继承来的属性，则会自动为该对象添加该属性。再次调用obj.hasOwnProperty(name)时，会返回true。如果直接修改原型对象中的属性值，则所有以该原型对象为原型的对象，且没有修改过该属性的对象，在查找属性值时，均会返回原型对象中修改过的值。
注意以下情况：
<pre>
	function Person(){};
	Person.prototype = {
		name:"ddf",
		f:["x","y"]
	}

	var p1 = new Person();
	var p2 = new Person();

	p1.f.push("z");
	// 输出["x","y","z"],因为p1.f.push()的时候先查找f，再修改f。但在查找时，
	//返回的是protoype中的f属性，所有修改之后，所有以该对象为原型的对象的该属性都修改了。
	console.log(p2.f); 
	
	p1.f = ["x","y"]; // 修改原型中的属性的时候会为该对象自动创建该属性。查找时不用再沿原型链查找
	console.log(p1); //输出["x","y"]
	console.log(p2); //输出["x","y","z"]
</pre>

删除属性：
只能删除该对象中定义的属性。在删除对象定义的属性的同时，会暴露出原型中的属性。即再次查找该属性的时候，会返回原型中的属性值。





